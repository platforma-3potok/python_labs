# Стек, очередь и односвязный список

Данный файл содержит описание трёх базовых структур данных: **стек**, **очередь** и **односвязный список**. Рассматриваются их определения, ключевые характеристики, основные операции, варианты реализации, области применения, а также преимущества и ограничения.

---

## Стек (Stack)

### Что такое стек

**Стек** — это фундаментальная структура данных, представляющая собой упорядоченную коллекцию элементов, работающую по принципу **LIFO (Last In — First Out)**. Это означает, что элемент, добавленный последним, будет извлечён первым.

Для наглядности можно представить стопку тарелок: новую тарелку кладут сверху, и берут тоже только верхнюю. Аналогично и в стеке — доступ возможен исключительно к вершине.

---

### Основные характеристики стека

- Однонаправленный доступ — операции выполняются только с вершиной  
- Динамический размер — количество элементов может увеличиваться и уменьшаться  
- Ограниченный набор операций  
- Отсутствие произвольного доступа к элементам  

---

### Типовые операции стека и их сложность

#### `push(item)` — добавление элемента

**Назначение:** добавляет новый элемент на вершину стека  
**Сложность:** `O(1)`

```python
def push(self, item):
    self._data.append(item)
````

---

#### `pop()` — извлечение элемента

**Назначение:** удаляет и возвращает верхний элемент стека
**Сложность:** `O(1)`

```python
def pop(self):
    if self.is_empty():
        raise IndexError("Стек пуст")
    return self._data.pop()
```

---

#### `peek()` / `top()` — просмотр вершины

**Назначение:** возвращает верхний элемент без его удаления
**Сложность:** `O(1)`

```python
def peek(self):
    if self.is_empty():
        return None
    return self._data[-1]
```

---

#### `is_empty()` — проверка на пустоту

```python
def is_empty(self):
    return len(self._data) == 0
```

---

#### `size()` / `len()` — получение размера

```python
def __len__(self):
    return len(self._data)
```

---

### Реализации стека

* На основе массива или списка
* На основе связного списка
* На основе массива фиксированного размера

---

### Практическое применение стеков

* Управление вызовами функций
* Проверка корректности вложенных конструкций (скобки, HTML/XML)
* Алгоритмы поиска в глубину (DFS)
* Отмена операций (Undo)
* Вычисление выражений
* Рекурсивные алгоритмы

---

### Преимущества и ограничения стека

**Преимущества:**

* Высокая скорость операций (`O(1)`)
* Простота реализации
* Низкие требования к памяти

**Ограничения:**

* Доступ только к вершине
* Поиск элемента за `O(n)`
* Отсутствие произвольного доступа

---

## Очередь (Queue)

### Что такое очередь

**Очередь** — это структура данных, организованная по принципу **FIFO (First In — First Out)**, то есть первый добавленный элемент извлекается первым.

Пример — обычная очередь в магазине или на кассе.

---

### Основные характеристики очереди

* Добавление элементов происходит в конец
* Извлечение — из начала
* Сохраняется порядок поступления
* Размер динамический

---

### Основные операции очереди

#### `enqueue(item)` — добавление элемента

**Сложность:** `O(1)`

```python
def enqueue(self, item):
    self._data.append(item)
```

---

#### `dequeue()` — извлечение элемента

**Сложность:** `O(1)` при использовании `deque`

```python
def dequeue(self):
    if self.is_empty():
        raise IndexError("Очередь пуста")
    return self._data.popleft()
```

---

#### `peek()` / `front()` — просмотр начала

```python
def peek(self):
    if self.is_empty():
        return None
    return self._data[0]
```

---

#### `is_empty()` — проверка на пустоту

```python
def is_empty(self):
    return len(self._data) == 0
```

---

#### `size()` / `len()` — размер очереди

```python
def __len__(self):
    return len(self._data)
```

---

### Реализации очереди

* `collections.deque`
* Связный список
* Кольцевой буфер
* Очередь на двух стеках

---

### Применение очередей

* Планирование процессов ОС
* Обработка запросов
* Буферизация данных
* Поиск в ширину (BFS)
* Очереди сообщений
* Печать документов

---

### Преимущества и ограничения очереди

**Преимущества:**

* `O(1)` для основных операций
* Справедливый порядок обработки
* Широкое практическое применение

**Ограничения:**

* Нет произвольного доступа
* Поиск за `O(n)`
* Возможные накладные расходы памяти

---

## Односвязный список (Singly Linked List)

### Что такое односвязный список

**Односвязный список** — это линейная структура данных, состоящая из узлов. Каждый узел хранит:

* значение (`value`)
* ссылку на следующий узел (`next`)

Последний узел указывает на `None`.

---

### Основные характеристики

* Динамический размер
* Последовательный доступ
* Элементы распределены в памяти
* Эффективные вставки и удаления

---

### Основные операции

#### `append(value)` — добавление в конец

**Сложность:** `O(1)` при наличии `tail`

```python
def append(self, value):
    new_node = Node(value)
    if self.head is None:
        self.head = self.tail = new_node
    else:
        self.tail.next = new_node
        self.tail = new_node
    self._size += 1
```

---

#### `prepend(value)` — добавление в начало

```python
def prepend(self, value):
    new_node = Node(value)
    new_node.next = self.head
    self.head = new_node
    if self.tail is None:
        self.tail = new_node
    self._size += 1
```

---

#### `insert(index, value)` — вставка по индексу

**Сложность:** `O(n)`

```python
def insert(self, index, value):
    if index < 0 or index > self._size:
        raise IndexError("Индекс вне диапазона")

    if index == 0:
        self.prepend(value)
    elif index == self._size:
        self.append(value)
    else:
        new_node = Node(value)
        current = self.head
        for _ in range(index - 1):
            current = current.next
        new_node.next = current.next
        current.next = new_node
        self._size += 1
```

---

#### `remove(value)` — удаление по значению

**Сложность:** `O(n)`

```python
def remove(self, value):
    if not self.head:
        return

    if self.head.value == value:
        self.head = self.head.next
        if self.head is None:
            self.tail = None
        self._size -= 1
        return

    current = self.head
    while current.next and current.next.value != value:
        current = current.next

    if current.next:
        current.next = current.next.next
        if current.next is None:
            self.tail = current
        self._size -= 1
```

---

#### Поиск элемента

```python
def contains(self, value):
    current = self.head
    while current:
        if current.value == value:
            return True
        current = current.next
    return False
```

---

#### Доступ по индексу

```python
def get(self, index):
    if index < 0 or index >= self._size:
        raise IndexError("Индекс вне диапазона")

    current = self.head
    for _ in range(index):
        current = current.next
    return current.value
```

---

### Варианты реализации

* Только `head`
* `head` + `tail`
* Фиктивный узел
* Кольцевой список

---

### Применение связных списков

* Динамические структуры данных
* Реализация стеков и очередей
* Управление памятью
* История операций
* Плейлисты
* Текстовые редакторы
* Хэш-таблицы
* Представление больших чисел

---

### Преимущества и ограничения

**Преимущества:**

* Не требует непрерывной памяти
* Гибкий размер
* Быстрые вставки и удаления

**Ограничения:**

* Доступ за `O(n)`
* Дополнительная память на ссылки
* Низкая кэш-локальность

---

## Сравнение массива и односвязного списка

| Критерий             | Массив           | Односвязный список |
| -------------------- | ---------------- | ------------------ |
| Доступ по индексу    | O(1)             | O(n)               |
| Вставка в начало     | O(n)             | O(1)               |
| Удаление из начала   | O(n)             | O(1)               |
| Вставка в конец      | O(1)*            | O(1) с tail        |
| Использование памяти | Более эффективно | Менее эффективно   |
| Локальность данных   | Высокая          | Низкая             |
| Динамический размер  | Ограничен        | Неограничен        |

* `O(1)` — амортизированное время для динамического массива.
